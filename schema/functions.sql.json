[
  "CREATE OR REPLACE FUNCTION fhirbase_genid()\nRETURNS text AS $$\n  select gen_random_uuid()::text\n$$ LANGUAGE sql;\n",
  "\nCREATE TYPE _resource AS (\n  id text,\n  txid bigint,\n  ts timestamptz,\n  resource_type text,\n  status resource_status,\n  resource jsonb\n);\n",
  "\nCREATE OR REPLACE FUNCTION _fhirbase_to_resource(x _resource)\nRETURNS jsonb AS $$\n select x.resource || jsonb_build_object(\n  'resourceType', x.resource_type,\n  'id', x.id,\n  'meta', coalesce(x.resource->'meta', '{}'::jsonb) || jsonb_build_object(\n    'lastUpdated', x.ts,\n    'versionId', x.txid::text\n  )\n );\n$$ LANGUAGE sql;\n",
  "\nCREATE OR REPLACE FUNCTION fhirbase_create(resource jsonb, txid bigint)\nRETURNS jsonb AS $FUNCTION$\nDECLARE\n  _sql text;\n  rt text;\n  rid text;\n  result jsonb;\nBEGIN\n    rt   := resource->>'resourceType';\n    rid  := coalesce(resource->>'id', fhirbase_genid());\n    _sql := format($SQL$\n      WITH archived AS (\n        INSERT INTO %s (id, txid, ts, status, resource)\n        SELECT id, txid, ts, status, resource\n        FROM %s\n        WHERE id = $2\n        RETURNING *\n      ), inserted AS (\n         INSERT INTO %s (id, ts, txid, status, resource)\n         VALUES ($2, current_timestamp, $1, 'created', $3)\n         ON CONFLICT (id)\n         DO UPDATE SET\n          txid = $1,\n          ts = current_timestamp,\n          status = 'recreated',\n          resource = $3\n         RETURNING *\n      )\n\n      select _fhirbase_to_resource(i.*) from inserted i\n\n      $SQL$,\n      rt || '_history', rt, rt, rt);\n\n  EXECUTE _sql\n  USING txid, rid, jsonb_set(resource, '{id}', to_jsonb(rid::text), true)\n  INTO result;\n\n  return result;\n\nEND\n$FUNCTION$ LANGUAGE plpgsql;\n",
  "\nCREATE OR REPLACE FUNCTION fhirbase_create(resource jsonb)\nRETURNS jsonb AS $FUNCTION$\n   SELECT fhirbase_create(resource, nextval('transaction_id_seq'));\n$FUNCTION$ LANGUAGE sql;\n",
  "\nCREATE OR REPLACE FUNCTION fhirbase_update(resource jsonb, txid bigint)\nRETURNS jsonb AS $FUNCTION$\nDECLARE\n  _sql text ;\n  rt text;\n  rid text;\n  result jsonb;\nBEGIN\n    rt   := resource->>'resourceType';\n    rid  := resource->>'id';\n\n    CASE WHEN (rid IS NULL) THEN\n      RAISE EXCEPTION 'Resource does not have and id' USING HINT = 'Resource does not have and id';\n    ELSE\n    END CASE;\n\n    _sql := format($SQL$\n      WITH archived AS (\n        INSERT INTO %s (id, txid, ts, status, resource)\n        SELECT id, txid, ts, status, resource\n        FROM %s\n        WHERE id = $2\n        RETURNING *\n      ), inserted AS (\n         INSERT INTO %s (id, ts, txid, status, resource)\n         VALUES ($2, current_timestamp, $1, 'created', $3)\n         ON CONFLICT (id)\n         DO UPDATE SET\n          txid = $1,\n          ts = current_timestamp,\n          status = 'updated',\n          resource = $3\n         RETURNING *\n      )\n\n      select _fhirbase_to_resource(i.*) from inserted i\n\n      $SQL$,\n      rt || '_history', rt, rt, rt);\n\n  EXECUTE _sql\n  USING txid, rid, (resource - 'id')\n  INTO result;\n\n  return result;\n\nEND\n$FUNCTION$ LANGUAGE plpgsql;\n",
  "\nCREATE OR REPLACE FUNCTION fhirbase_update(resource jsonb)\nRETURNS jsonb AS $FUNCTION$\n   SELECT fhirbase_update(resource, nextval('transaction_id_seq'));\n$FUNCTION$ LANGUAGE sql;\n",
  "\nCREATE OR REPLACE FUNCTION fhirbase_read(resource_type text, id text)\nRETURNS jsonb AS $FUNCTION$\nDECLARE\n  _sql text;\n  result jsonb;\nBEGIN\n  _sql := format($SQL$\n    SELECT _fhirbase_to_resource(row(r.*)::_resource) FROM %s r WHERE r.id = $1\n  $SQL$,\n  resource_type\n  );\n\n  EXECUTE _sql USING id INTO result;\n\n  return result;\nEND\n$FUNCTION$ LANGUAGE plpgsql;\n",
  "\nCREATE OR REPLACE FUNCTION fhirbase_delete(resource_type text, id text, txid bigint)\nRETURNS jsonb AS $FUNCTION$\nDECLARE\n  _sql text;\n  rt text;\n  rid text;\n  result jsonb;\nBEGIN\n    rt   := resource_type;\n    rid  := id;\n    _sql := format($SQL$\n      WITH archived AS (\n        INSERT INTO %s (id, txid, ts, status, resource)\n        SELECT id, txid, ts, status, resource\n        FROM %s WHERE id = $2\n        RETURNING *\n      ), deleted AS (\n         INSERT INTO %s (id, txid, ts, status, resource)\n         SELECT id, $1, current_timestamp, status, resource\n         FROM %s WHERE id = $2\n         RETURNING *\n      ), dropped AS (\n         DELETE FROM %s WHERE id = $2 RETURNING *\n      )\n      select _fhirbase_to_resource(i.*) from archived i\n\n      $SQL$,\n      rt || '_history', rt, rt || '_history', rt, rt);\n\n  EXECUTE _sql\n  USING txid, rid\n  INTO result;\n\n  return result;\n\nEND\n$FUNCTION$ LANGUAGE plpgsql;\n",
  "\nCREATE OR REPLACE FUNCTION fhirbase_delete(resource_type text, id text)\nRETURNS jsonb AS $FUNCTION$\n   SELECT fhirbase_delete(resource_type, id, nextval('transaction_id_seq'));\n$FUNCTION$ LANGUAGE sql;"
]
